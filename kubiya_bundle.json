{
  "tools": [
    {
      "name": "store_request",
      "source": null,
      "alias": null,
      "description": "Stores request data in Redis ElastiCache and returns a unique request ID",
      "type": "docker",
      "content": "\npip install -r /tmp/requirements.txt > /dev/null 2>&1\n\npython /tmp/main.py \"{{ .user_name }}\" \"{{ .message }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "user_name",
          "type": null,
          "description": "Name of the user",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        },
        {
          "name": "message",
          "type": null,
          "description": "Message to store",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "REDIS_HOST",
        "REDIS_PORT"
      ],
      "secrets": [],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/main.py",
          "content": "import argparse\nimport redis\nimport json\nimport os\nimport logging\nimport uuid\nfrom typing import Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass RedisConnectionError(Exception):\n    \"\"\"Custom exception for Redis connection errors\"\"\"\n    pass\n\n\ndef connect_to_redis() -> redis.Redis:\n    \"\"\"Establish connection to Redis using environment variables\"\"\"\n    host = os.getenv('REDIS_HOST')\n    port = int(os.getenv('REDIS_PORT', '6379'))\n    \n    if not host:\n        logger.error(\"REDIS_HOST environment variable is not set\")\n        raise RedisConnectionError(\"REDIS_HOST environment variable is not set\")\n    \n    try:\n        # Log connection attempt\n        logger.info(f\"Attempting to connect to Redis at {host}:{port}\")\n        \n        # Add connection timeout to avoid hanging\n        client = redis.Redis(\n            host=host,\n            port=port,\n            decode_responses=True,\n            socket_timeout=5.0,  # 5 second timeout\n            socket_connect_timeout=5.0\n        )\n        \n        # Test the connection with timeout\n        try:\n            client.ping()\n        except redis.TimeoutError:\n            logger.error(f\"Connection timeout while connecting to Redis at {host}:{port}\")\n            raise RedisConnectionError(f\"Connection timeout while connecting to Redis at {host}:{port}\")\n        except redis.ConnectionError as e:\n            if \"name resolution\" in str(e).lower():\n                logger.error(f\"DNS resolution failed for Redis host '{host}'. Please verify the hostname is correct.\")\n                raise RedisConnectionError(f\"DNS resolution failed for Redis host '{host}'. Please verify the hostname is correct.\")\n            raise\n            \n        logger.info(f\"Successfully connected to Redis at {host}:{port}\")\n        return client\n        \n    except redis.ConnectionError as e:\n        logger.error(f\"Failed to connect to Redis: {str(e)}\")\n        raise RedisConnectionError(f\"Failed to connect to Redis: {str(e)}\")\n    except Exception as e:\n        logger.error(f\"Unexpected error while connecting to Redis: {str(e)}\")\n        raise RedisConnectionError(f\"Unexpected error while connecting to Redis: {str(e)}\")\n\n\ndef generate_unique_request_id(redis_client: redis.Redis) -> str:\n    \"\"\"Generate a unique request ID and ensure it doesn't exist in Redis\"\"\"\n    max_attempts = 5\n    for _ in range(max_attempts):\n        # Generate a random UUID4 and take first 8 characters\n        request_id = str(uuid.uuid4())[:8]\n        \n        # Check if this ID already exists\n        if not redis_client.exists(f\"request:{request_id}\"):\n            logger.info(f\"Generated unique request ID: {request_id}\")\n            return request_id\n    \n    # If we couldn't generate a unique ID after max attempts\n    raise ValueError(\"Could not generate unique request ID after multiple attempts\")\n\n\ndef store_request_data(\n    redis_client: redis.Redis,\n    user_name: str,\n    message: str,\n) -> tuple[str, bool]:\n    \"\"\"Store request data in Redis with auto-generated request ID\"\"\"\n    try:\n        if not user_name or not message:\n            logger.error(\"Missing required parameters\")\n            raise ValueError(\"user_name and message are required\")\n\n        # Generate unique request ID\n        request_id = generate_unique_request_id(redis_client)\n\n        data = {\n            \"request_id\": request_id,\n            \"user_name\": user_name,\n            \"message\": message,\n        }\n        \n        logger.info(f\"Attempting to store data for request_id: {request_id}\")\n        # Store as a hash\n        redis_client.hset(f\"request:{request_id}\", mapping=data)\n        # Set expiration for 24 hours\n        redis_client.expire(f\"request:{request_id}\", 86400)\n        \n        logger.info(f\"Successfully stored data for request_id: {request_id}\")\n        return request_id, True\n    except redis.RedisError as e:\n        logger.error(f\"Redis error while storing data: {str(e)}\")\n        return None, False\n    except Exception as e:\n        logger.error(f\"Unexpected error while storing data: {str(e)}\")\n        return None, False\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Store request data in Redis\")\n    parser.add_argument(\"user_name\", help=\"Name of the user\")\n    parser.add_argument(\"message\", help=\"Message to store\")\n\n    args = parser.parse_args()\n\n    try:\n        # Connect to Redis using environment variables\n        redis_client = connect_to_redis()\n\n        # Store the data\n        request_id, success = store_request_data(\n            redis_client,\n            args.user_name,\n            args.message,\n        )\n\n        if success:\n            logger.info(f\"Successfully stored request {request_id} in Redis\")\n            # Print the request ID so it can be captured by the tool\n            print(request_id)\n        else:\n            logger.error(\"Failed to store request in Redis\")\n            exit(1)\n    except RedisConnectionError as e:\n        logger.error(f\"Redis connection error: {str(e)}\")\n        exit(1)\n    except ValueError as e:\n        logger.error(f\"Validation error: {str(e)}\")\n        exit(1)\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        exit(1)\n    finally:\n        try:\n            redis_client.close()\n            logger.debug(\"Redis connection closed\")\n        except:\n            pass\n"
        },
        {
          "source": null,
          "destination": "/tmp/requirements.txt",
          "content": "redis>=5.0.0\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"store_request\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"user_name (Required)<br/>Name of the user\"):::paramClass\n        Param1(\"message (Required)<br/>Message to store\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install -r /tmp/requirements.txt > /dev/null ...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>REDIS_HOST<br/>REDIS_PORT\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    },
    {
      "name": "send_to_slack",
      "source": null,
      "alias": null,
      "description": "Retrieves request data (user name, message) from Redis using the request ID and sends it to Slack",
      "type": "docker",
      "content": "\npip install -r /tmp/requirements.txt > /dev/null 2>&1\n\npython /tmp/send_to_slack.py \"{{ .request_id }}\" \"{{ .channel }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "request_id",
          "type": null,
          "description": "Request ID to retrieve user name and message from Redis",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "REDIS_HOST",
        "REDIS_PORT"
      ],
      "secrets": [
        "SLACK_API_TOKEN"
      ],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/send_to_slack.py",
          "content": "import argparse\nimport redis\nimport os\nimport logging\nfrom slack_sdk import WebClient\nfrom slack_sdk.errors import SlackApiError\nfrom typing import Optional, Dict\nfrom fuzzywuzzy import fuzz\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass RedisConnectionError(Exception):\n    \"\"\"Custom exception for Redis connection errors\"\"\"\n    pass\n\n\ndef connect_to_redis() -> redis.Redis:\n    \"\"\"Establish connection to Redis using environment variables\"\"\"\n    host = os.getenv('REDIS_HOST')\n    port = int(os.getenv('REDIS_PORT', '6379'))\n    \n    if not host:\n        logger.error(\"REDIS_HOST environment variable is not set\")\n        raise RedisConnectionError(\"REDIS_HOST environment variable is not set\")\n    \n    try:\n        logger.info(f\"Attempting to connect to Redis at {host}:{port}\")\n        client = redis.Redis(\n            host=host,\n            port=port,\n            decode_responses=True,\n            socket_timeout=5.0,\n            socket_connect_timeout=5.0\n        )\n        \n        client.ping()\n        logger.info(f\"Successfully connected to Redis at {host}:{port}\")\n        return client\n        \n    except redis.ConnectionError as e:\n        logger.error(f\"Failed to connect to Redis: {str(e)}\")\n        raise RedisConnectionError(f\"Failed to connect to Redis: {str(e)}\")\n\n\ndef get_request_data(redis_client: redis.Redis, request_id: str) -> Optional[Dict]:\n    \"\"\"Retrieve request data from Redis\"\"\"\n    try:\n        data = redis_client.hgetall(f\"request:{request_id}\")\n        if not data:\n            logger.error(f\"No data found for request_id: {request_id}\")\n            return None\n        \n        logger.info(f\"Successfully retrieved data for request_id: {request_id}\")\n        return data\n    except redis.RedisError as e:\n        logger.error(f\"Redis error while retrieving data: {str(e)}\")\n        return None\n\n\ndef create_block_kit_message(message: str, user_name: str) -> list:\n    \"\"\"Create a Block Kit formatted message\"\"\"\n    return [\n        {\n            \"type\": \"section\",\n            \"text\": {\"type\": \"mrkdwn\", \"text\": message}\n        },\n        {\n            \"type\": \"divider\"\n        },\n        {\n            \"type\": \"context\",\n            \"elements\": [\n                {\n                    \"type\": \"mrkdwn\",\n                    \"text\": f\":speech_balloon: Message sent on behalf of {user_name}\"\n                }\n            ]\n        }\n    ]\n\n\ndef send_slack_message(channel: str, message: str, user_name: str) -> bool:\n    \"\"\"Send message to Slack channel with improved formatting and error handling\"\"\"\n    slack_token = os.getenv('SLACK_API_TOKEN')\n    if not slack_token:\n        logger.error(\"SLACK_API_TOKEN environment variable is not set\")\n        raise ValueError(\"SLACK_API_TOKEN environment variable is not set\")\n\n    client = WebClient(token=slack_token)\n    \n    # Hardcode channel to #testing\n    channel = \"#testing\"\n    \n    try:\n        # Create Block Kit message\n        blocks = create_block_kit_message(message, user_name)\n        fallback_text = f\"{message}\\n\\n_Message sent on behalf of {user_name}_\"\n\n        # Try sending with Block Kit first\n        try:\n            response = client.chat_postMessage(\n                channel=channel,\n                blocks=blocks,\n                text=fallback_text\n            )\n            logger.info(f\"Block Kit message sent successfully to {channel}\")\n        except SlackApiError as block_error:\n            logger.warning(f\"Failed to send Block Kit message: {block_error}. Falling back to regular message.\")\n            response = client.chat_postMessage(\n                channel=channel,\n                text=fallback_text\n            )\n            logger.info(f\"Regular message sent successfully to {channel}\")\n        \n        return True\n        \n    except SlackApiError as e:\n        logger.error(f\"Failed to send message to Slack: {str(e)}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Retrieve request data from Redis and send to Slack\")\n    parser.add_argument(\"request_id\", help=\"Request ID to retrieve from Redis\")\n    parser.add_argument(\"channel\", help=\"Slack channel to send the message to\")\n\n    args = parser.parse_args()\n\n    try:\n        # Connect to Redis\n        redis_client = connect_to_redis()\n\n        # Get the data\n        data = get_request_data(redis_client, args.request_id)\n        if not data:\n            logger.error(\"Failed to retrieve data from Redis\")\n            exit(1)\n\n        # Send to Slack\n        success = send_slack_message(\n            channel=args.channel,\n            message=data['message'],\n            user_name=data['user_name']\n        )\n\n        if success:\n            logger.info(f\"Successfully processed request {args.request_id}\")\n        else:\n            logger.error(f\"Failed to send message to Slack for request {args.request_id}\")\n            exit(1)\n\n    except RedisConnectionError as e:\n        logger.error(f\"Redis connection error: {str(e)}\")\n        exit(1)\n    except ValueError as e:\n        logger.error(f\"Validation error: {str(e)}\")\n        exit(1)\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        exit(1)\n    finally:\n        try:\n            redis_client.close()\n            logger.debug(\"Redis connection closed\")\n        except:\n            pass \n"
        },
        {
          "source": null,
          "destination": "/tmp/requirements.txt",
          "content": "redis>=5.0.0\nslack-sdk>=3.0.0\nfuzzywuzzy>=0.18.0\npython-Levenshtein>=0.21.0\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"send_to_slack\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"request_id (Required)<br/>Request ID to retrieve user name and message from Redis\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install -r /tmp/requirements.txt > /dev/null ...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>REDIS_HOST<br/>REDIS_PORT\"):::envClass\n        Secrets(\"Secrets:<br/>SLACK_API_TOKEN\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    },
    {
      "name": "terraform_plan",
      "source": null,
      "alias": null,
      "description": "Generates a Terraform plan for Redis ElastiCache infrastructure and stores it in Redis",
      "type": "docker",
      "content": "\n# Install required packages silently\napt-get update > /dev/null 2>&1\napt-get install -y lsb-release gnupg software-properties-common curl > /dev/null 2>&1\n\n# Install Terraform silently\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg > /dev/null 2>&1\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | tee /etc/apt/sources.list.d/hashicorp.list > /dev/null 2>&1\napt-get update > /dev/null 2>&1 && apt-get install -y terraform > /dev/null 2>&1\n\npip install -r /tmp/requirements.txt > /dev/null 2>&1\n\npython /tmp/terraform_plan_tool.py \"{{ .user_name }}\" --environment \"{{ .environment }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "user_name",
          "type": null,
          "description": "Name of the user requesting the change",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        },
        {
          "name": "environment",
          "type": null,
          "description": "Target environment (dev, staging, prod)",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "REDIS_HOST",
        "REDIS_PORT",
        "AWS_PROFILE"
      ],
      "secrets": [],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/terraform_plan_tool.py",
          "content": "import argparse\nimport redis\nimport json\nimport os\nimport logging\nimport uuid\nimport subprocess\nimport boto3\nimport time\nfrom typing import Optional, Tuple, Dict\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# Add near the top of the file, after the imports\nDEFAULT_TERRAFORM_DIR = os.path.join(os.path.dirname(__file__), \"terraform\")\n\n# Add these constants near the top of the file after DEFAULT_TERRAFORM_DIR\nTERRAFORM_MAIN = '''provider \"aws\" {\n  region = var.aws_region\n}\n\nresource \"aws_s3_bucket\" \"demo_bucket\" {\n  bucket = \"demo-bucket-${var.environment}-${random_string.suffix.result}\"\n  \n  tags = {\n    Environment = var.environment\n    Project     = \"Demo\"\n  }\n}\n\n# Create a random suffix to ensure bucket name uniqueness\nresource \"random_string\" \"suffix\" {\n  length  = 8\n  special = false\n  upper   = false\n}\n\n# Add bucket versioning\nresource \"aws_s3_bucket_versioning\" \"demo_bucket\" {\n  bucket = aws_s3_bucket.demo_bucket.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}'''\n\nTERRAFORM_VARS = '''variable \"aws_region\" {\n  description = \"AWS region to deploy resources\"\n  type        = string\n  default     = \"us-west-2\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod)\"\n  type        = string\n}'''\n\nTERRAFORM_TFVARS = '''environment = \"dev\"\naws_region   = \"us-west-2\"'''\n\ndef setup_terraform_files(working_dir: str) -> None:\n    \"\"\"Create Terraform configuration files in the working directory\"\"\"\n    os.makedirs(working_dir, exist_ok=True)\n    \n    # Write main.tf\n    with open(os.path.join(working_dir, \"main.tf\"), \"w\") as f:\n        f.write(TERRAFORM_MAIN)\n    \n    # Write variables.tf\n    with open(os.path.join(working_dir, \"variables.tf\"), \"w\") as f:\n        f.write(TERRAFORM_VARS)\n    \n    # Write terraform.tfvars\n    with open(os.path.join(working_dir, \"terraform.tfvars\"), \"w\") as f:\n        f.write(TERRAFORM_TFVARS)\n    \n    logger.info(f\"Created Terraform configuration files in {working_dir}\")\n\nclass RedisConnectionError(Exception):\n    \"\"\"Custom exception for Redis connection errors\"\"\"\n    pass\n\n\nclass TerraformError(Exception):\n    \"\"\"Custom exception for Terraform execution errors\"\"\"\n    pass\n\n\ndef connect_to_redis() -> redis.Redis:\n    \"\"\"Establish connection to Redis using environment variables\"\"\"\n    host = os.getenv('REDIS_HOST')\n    port = int(os.getenv('REDIS_PORT', '6379'))\n    \n    if not host:\n        logger.error(\"REDIS_HOST environment variable is not set\")\n        raise RedisConnectionError(\"REDIS_HOST environment variable is not set\")\n    \n    try:\n        logger.info(f\"Attempting to connect to Redis at {host}:{port}\")\n        client = redis.Redis(\n            host=host,\n            port=port,\n            decode_responses=True,\n            socket_timeout=5.0,\n            socket_connect_timeout=5.0\n        )\n        \n        client.ping()\n        logger.info(f\"Successfully connected to Redis at {host}:{port}\")\n        return client\n        \n    except (redis.ConnectionError, redis.TimeoutError) as e:\n        logger.error(f\"Failed to connect to Redis: {str(e)}\")\n        raise RedisConnectionError(f\"Failed to connect to Redis: {str(e)}\")\n\n\ndef generate_unique_request_id(redis_client: redis.Redis) -> str:\n    \"\"\"Generate a unique request ID and ensure it doesn't exist in Redis\"\"\"\n    max_attempts = 5\n    for _ in range(max_attempts):\n        request_id = str(uuid.uuid4())[:8]\n        if not redis_client.exists(f\"terraform_plan:{request_id}\"):\n            logger.info(f\"Generated unique request ID: {request_id}\")\n            return request_id\n    \n    raise ValueError(\"Could not generate unique request ID after multiple attempts\")\n\n\ndef verify_aws_credentials() -> bool:\n    \"\"\"Verify AWS credentials are properly configured\"\"\"\n    try:\n        boto3.client('sts').get_caller_identity()\n        logger.info(\"AWS credentials verified successfully\")\n        return True\n    except Exception as e:\n        logger.error(f\"AWS credentials verification failed: {str(e)}\")\n        return False\n\n\ndef run_terraform_plan(working_dir: str, vars_file: Optional[str] = None) -> str:\n    \"\"\"Execute terraform plan and return the output\"\"\"\n    try:\n        # Verify AWS credentials first\n        if not verify_aws_credentials():\n            raise TerraformError(\"AWS credentials are not properly configured\")\n\n        # Create Terraform files if using default directory\n        if working_dir == DEFAULT_TERRAFORM_DIR:\n            setup_terraform_files(working_dir)\n        \n        # Initialize Terraform first\n        init_cmd = [\"terraform\", \"init\"]\n        subprocess.run(init_cmd, cwd=working_dir, check=True, capture_output=True)\n        \n        # Construct plan command\n        plan_cmd = [\"terraform\", \"plan\", \"-no-color\"]\n        if vars_file:\n            plan_cmd.extend([\"-var-file\", vars_file])\n        \n        # Add output to JSON format\n        plan_cmd.extend([\"-out=tfplan\"])\n        \n        # Run terraform plan\n        logger.info(\"Executing Terraform plan...\")\n        result = subprocess.run(\n            plan_cmd,\n            cwd=working_dir,\n            check=True,\n            capture_output=True,\n            text=True\n        )\n        \n        # Capture the human-readable output\n        plan_output = result.stdout\n        \n        # Show plan in JSON format\n        show_cmd = [\"terraform\", \"show\", \"-json\", \"tfplan\"]\n        show_result = subprocess.run(\n            show_cmd,\n            cwd=working_dir,\n            check=True,\n            capture_output=True,\n            text=True\n        )\n        \n        return plan_output, show_result.stdout\n        \n    except subprocess.CalledProcessError as e:\n        error_message = f\"Terraform command failed: {e.stderr}\"\n        logger.error(error_message)\n        raise TerraformError(error_message)\n\n\ndef store_terraform_plan(\n    redis_client: redis.Redis,\n    user_name: str,\n    environment: str,\n) -> Tuple[str, bool]:\n    \"\"\"Generate and store Terraform plan data in Redis\"\"\"\n    try:\n        if not user_name or not environment:\n            raise ValueError(\"user_name and environment are required\")\n\n        # Generate unique request ID\n        request_id = generate_unique_request_id(redis_client)\n\n        # Use default working directory\n        working_dir = DEFAULT_TERRAFORM_DIR\n\n        # Modify terraform.tfvars content with requested environment\n        tfvars_content = TERRAFORM_TFVARS.replace(\n            'environment = \"dev\"',\n            f'environment = \"{environment}\"'\n        )\n\n        # Ensure directory exists and write files\n        os.makedirs(working_dir, exist_ok=True)\n        \n        # Write all Terraform files with the modified environment\n        with open(os.path.join(working_dir, \"main.tf\"), \"w\") as f:\n            f.write(TERRAFORM_MAIN)\n        \n        with open(os.path.join(working_dir, \"variables.tf\"), \"w\") as f:\n            f.write(TERRAFORM_VARS)\n        \n        with open(os.path.join(working_dir, \"terraform.tfvars\"), \"w\") as f:\n            f.write(tfvars_content)\n\n        # Run terraform plan\n        plan_output, plan_json = run_terraform_plan(working_dir)\n\n        # Store both the plan data and the Terraform configurations\n        data = {\n            \"request_id\": request_id,\n            \"user_name\": user_name,\n            \"environment\": environment,\n            \"plan_output\": plan_output,\n            \"plan_json\": plan_json,\n            \"timestamp\": str(int(time.time())),\n            \"terraform_main\": TERRAFORM_MAIN,\n            \"terraform_vars\": TERRAFORM_VARS,\n            \"terraform_tfvars\": tfvars_content\n        }\n        \n        redis_client.hset(f\"terraform_plan:{request_id}\", mapping=data)\n        redis_client.expire(f\"terraform_plan:{request_id}\", 86400)\n        \n        logger.info(f\"Successfully stored Terraform plan data for request_id: {request_id}\")\n        return request_id, True\n\n    except (redis.RedisError, TerraformError, ValueError) as e:\n        logger.error(f\"Error while storing Terraform plan: {str(e)}\")\n        return None, False\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate and store Terraform plan\")\n    parser.add_argument(\"user_name\", help=\"Name of the user requesting the change\")\n    parser.add_argument(\n        \"--environment\",\n        required=True,\n        help=\"Target environment for the change (e.g., dev, staging, prod)\"\n    )\n\n    args = parser.parse_args()\n\n    try:\n        # Connect to Redis\n        redis_client = connect_to_redis()\n\n        # Generate and store the plan\n        request_id, success = store_terraform_plan(\n            redis_client,\n            args.user_name,\n            args.environment\n        )\n\n        if success:\n            logger.info(f\"Successfully stored Terraform plan with request ID: {request_id}\")\n            # Print the request ID for capture by the tool\n            print(request_id)\n        else:\n            logger.error(\"Failed to store Terraform plan\")\n            exit(1)\n\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        exit(1)\n    finally:\n        try:\n            redis_client.close()\n            logger.debug(\"Redis connection closed\")\n        except:\n            pass \n"
        },
        {
          "source": null,
          "destination": "/tmp/requirements.txt",
          "content": "redis>=5.0.0\nboto3>=1.26.0\n"
        },
        {
          "source": "$HOME/.aws/credentials",
          "destination": "/root/.aws/credentials",
          "content": null
        },
        {
          "source": "$HOME/.aws/config",
          "destination": "/root/.aws/config",
          "content": null
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"terraform_plan\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"user_name (Required)<br/>Name of the user requesting the change\"):::paramClass\n        Param1(\"environment (Required)<br/>Target environment (dev, staging, prod)\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/># Install required packages silently<br/>apt-get upda...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>REDIS_HOST<br/>REDIS_PORT<br/>AWS_PROFILE\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    },
    {
      "name": "terraform_apply",
      "source": null,
      "alias": null,
      "description": "Applies a previously generated Terraform plan using the request ID",
      "type": "docker",
      "content": "\n# Install required packages\napt-get update && apt-get install -y lsb-release gnupg software-properties-common curl\n\n# Install Terraform\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | tee /etc/apt/sources.list.d/hashicorp.list\napt-get update && apt-get install -y terraform\n\npip install -r /tmp/requirements.txt > /dev/null 2>&1\n\npython /tmp/terraform_apply_tool.py \"{{ .request_id }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "request_id",
          "type": null,
          "description": "Request ID from the terraform plan",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "REDIS_HOST",
        "REDIS_PORT",
        "AWS_PROFILE"
      ],
      "secrets": [],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/terraform_apply_tool.py",
          "content": "import argparse\nimport redis\nimport json\nimport os\nimport logging\nimport subprocess\nfrom typing import Optional, Dict\nimport boto3\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# Use the same default directory as the plan tool\nDEFAULT_TERRAFORM_DIR = os.path.join(os.path.dirname(__file__), \"terraform\")\n\nclass RedisConnectionError(Exception):\n    \"\"\"Custom exception for Redis connection errors\"\"\"\n    pass\n\nclass TerraformError(Exception):\n    \"\"\"Custom exception for Terraform execution errors\"\"\"\n    pass\n\ndef connect_to_redis() -> redis.Redis:\n    \"\"\"Establish connection to Redis using environment variables\"\"\"\n    host = os.getenv('REDIS_HOST')\n    port = int(os.getenv('REDIS_PORT', '6379'))\n    \n    if not host:\n        logger.error(\"REDIS_HOST environment variable is not set\")\n        raise RedisConnectionError(\"REDIS_HOST environment variable is not set\")\n    \n    try:\n        logger.info(f\"Attempting to connect to Redis at {host}:{port}\")\n        client = redis.Redis(\n            host=host,\n            port=port,\n            decode_responses=True,\n            socket_timeout=5.0,\n            socket_connect_timeout=5.0\n        )\n        \n        client.ping()\n        logger.info(f\"Successfully connected to Redis at {host}:{port}\")\n        return client\n        \n    except (redis.ConnectionError, redis.TimeoutError) as e:\n        logger.error(f\"Failed to connect to Redis: {str(e)}\")\n        raise RedisConnectionError(f\"Failed to connect to Redis: {str(e)}\")\n\ndef get_plan_data(redis_client: redis.Redis, request_id: str) -> Dict:\n    \"\"\"Retrieve plan data from Redis\"\"\"\n    plan_data = redis_client.hgetall(f\"terraform_plan:{request_id}\")\n    \n    if not plan_data:\n        raise ValueError(f\"No plan data found for request ID: {request_id}\")\n    \n    return plan_data\n\ndef setup_terraform_files(working_dir: str, plan_data: Dict) -> None:\n    \"\"\"Recreate Terraform configuration files using data from Redis\"\"\"\n    os.makedirs(working_dir, exist_ok=True)\n    \n    # Write main.tf\n    with open(os.path.join(working_dir, \"main.tf\"), \"w\") as f:\n        f.write(plan_data['terraform_main'])\n    \n    # Write variables.tf\n    with open(os.path.join(working_dir, \"variables.tf\"), \"w\") as f:\n        f.write(plan_data['terraform_vars'])\n    \n    # Write terraform.tfvars (already contains correct environment)\n    with open(os.path.join(working_dir, \"terraform.tfvars\"), \"w\") as f:\n        f.write(plan_data['terraform_tfvars'])\n\ndef verify_aws_credentials() -> bool:\n    \"\"\"Verify AWS credentials are properly configured\"\"\"\n    try:\n        boto3.client('sts').get_caller_identity()\n        logger.info(\"AWS credentials verified successfully\")\n        return True\n    except Exception as e:\n        logger.error(f\"AWS credentials verification failed: {str(e)}\")\n        return False\n\ndef run_terraform_apply(working_dir: str) -> str:\n    \"\"\"Execute terraform apply\"\"\"\n    try:\n        # Verify AWS credentials first\n        if not verify_aws_credentials():\n            raise TerraformError(\"AWS credentials are not properly configured\")\n\n        # Initialize Terraform first\n        init_cmd = [\"terraform\", \"init\"]\n        subprocess.run(init_cmd, cwd=working_dir, check=True, capture_output=True)\n        \n        # Run terraform apply\n        logger.info(\"Executing Terraform apply...\")\n        apply_cmd = [\"terraform\", \"apply\", \"-auto-approve\", \"-no-color\"]\n        result = subprocess.run(\n            apply_cmd,\n            cwd=working_dir,\n            check=True,\n            capture_output=True,\n            text=True\n        )\n        \n        return result.stdout\n        \n    except subprocess.CalledProcessError as e:\n        error_message = f\"Terraform command failed: {e.stderr}\"\n        logger.error(error_message)\n        raise TerraformError(error_message)\n\ndef execute_terraform_apply(redis_client: redis.Redis, request_id: str) -> bool:\n    \"\"\"Execute Terraform apply using stored plan data\"\"\"\n    try:\n        # Get the stored plan data\n        plan_data = get_plan_data(redis_client, request_id)\n        \n        # Setup Terraform files using the stored configurations\n        working_dir = DEFAULT_TERRAFORM_DIR\n        setup_terraform_files(working_dir, plan_data)\n        \n        # Run terraform apply\n        apply_output = run_terraform_apply(working_dir)\n        \n        # Store the apply results in Redis\n        apply_data = {\n            \"apply_output\": apply_output,\n            \"apply_timestamp\": str(time.time()),\n            \"status\": \"completed\"\n        }\n        redis_client.hset(f\"terraform_plan:{request_id}\", mapping=apply_data)\n        \n        logger.info(f\"Successfully applied Terraform changes for request ID: {request_id}\")\n        return True\n\n    except (redis.RedisError, TerraformError, ValueError) as e:\n        logger.error(f\"Error during Terraform apply: {str(e)}\")\n        # Store the error in Redis\n        redis_client.hset(\n            f\"terraform_plan:{request_id}\",\n            mapping={\n                \"status\": \"failed\",\n                \"error\": str(e)\n            }\n        )\n        return False\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Execute Terraform apply from stored plan\")\n    parser.add_argument(\n        \"request_id\",\n        help=\"Request ID from the terraform plan\"\n    )\n\n    args = parser.parse_args()\n\n    try:\n        # Connect to Redis\n        redis_client = connect_to_redis()\n\n        # Execute the apply\n        success = execute_terraform_apply(redis_client, args.request_id)\n\n        if not success:\n            logger.error(\"Failed to apply Terraform changes\")\n            exit(1)\n\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        exit(1)\n    finally:\n        try:\n            redis_client.close()\n            logger.debug(\"Redis connection closed\")\n        except:\n            pass \n"
        },
        {
          "source": null,
          "destination": "/tmp/requirements.txt",
          "content": "redis>=5.0.0\nboto3>=1.26.0\n"
        },
        {
          "source": "$HOME/.aws/credentials",
          "destination": "/root/.aws/credentials",
          "content": null
        },
        {
          "source": "$HOME/.aws/config",
          "destination": "/root/.aws/config",
          "content": null
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"terraform_apply\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"request_id (Required)<br/>Request ID from the terraform plan\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/># Install required packages<br/>apt-get update && apt...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>REDIS_HOST<br/>REDIS_PORT<br/>AWS_PROFILE\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    },
    {
      "name": "store_favorites",
      "source": null,
      "alias": null,
      "description": "Stores user's favorite color and animal in Redis and returns a unique request ID",
      "type": "docker",
      "content": "\npip install -r /tmp/requirements.txt > /dev/null 2>&1\n\npython /tmp/redis_store_example.py --color \"{{ .color }}\" --animal \"{{ .animal }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "color",
          "type": null,
          "description": "User's favorite color",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        },
        {
          "name": "animal",
          "type": null,
          "description": "User's favorite animal",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "REDIS_HOST",
        "REDIS_PORT",
        "KUBIYA_USER_EMAIL"
      ],
      "secrets": [],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/redis_store_example.py",
          "content": "import time\nimport redis\nimport json\nimport logging\nimport uuid\nimport os\nfrom typing import Dict, Optional\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass RedisConnectionError(Exception):\n    \"\"\"Custom exception for Redis connection errors\"\"\"\n    pass\n\ndef connect_to_redis() -> redis.Redis:\n    \"\"\"Establish connection to Redis using environment variables\"\"\"\n    host = os.getenv('REDIS_HOST')\n    port = int(os.getenv('REDIS_PORT', '6379'))\n    \n    if not host:\n        logger.error(\"REDIS_HOST environment variable is not set\")\n        raise RedisConnectionError(\"REDIS_HOST environment variable is not set\")\n    \n    try:\n        logger.info(f\"Attempting to connect to Redis at {host}:{port}\")\n        client = redis.Redis(\n            host=host,\n            port=port,\n            decode_responses=True,\n            socket_timeout=5.0,\n            socket_connect_timeout=5.0\n        )\n        \n        client.ping()\n        logger.info(f\"Successfully connected to Redis at {host}:{port}\")\n        return client\n        \n    except (redis.ConnectionError, redis.TimeoutError) as e:\n        logger.error(f\"Failed to connect to Redis: {str(e)}\")\n        raise RedisConnectionError(f\"Failed to connect to Redis: {str(e)}\")\n\nclass RedisStore:\n    def __init__(self):\n        self.client = connect_to_redis()\n    \n    def generate_unique_id(self) -> str:\n        \"\"\"Generate a unique ID for storing data\"\"\"\n        return str(uuid.uuid4())[:8]\n    \n    def store_user_data(self, user_data: Dict) -> Optional[str]:\n        \"\"\"\n        Store user data in Redis with a unique ID\n        Returns the ID if successful, None if failed\n        \"\"\"\n        try:\n            # Generate unique ID\n            data_id = self.generate_unique_id()\n            \n            # Add timestamp and user email from environment\n            user_data['timestamp'] = str(int(time.time()))\n            user_data['email'] = os.getenv('KUBIYA_USER_EMAIL')\n            \n            # Store in Redis without expiration\n            self.client.hset(f\"user_profile:{data_id}\", mapping=user_data)\n            \n            logger.info(f\"Successfully stored user data with ID: {data_id}\")\n            return data_id\n            \n        except redis.RedisError as e:\n            logger.error(f\"Failed to store data in Redis: {str(e)}\")\n            return None\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Store request data in Redis\")\n    parser.add_argument(\n        \"--color\",\n        required=True,\n        help=\"Favorite color\"\n    )\n    parser.add_argument(\n        \"--animal\",\n        required=True,\n        help=\"Favorite animal\"\n    )\n\n    args = parser.parse_args()\n\n    try:\n        # Create Redis store instance\n        redis_store = RedisStore()\n        \n        # Example request with two simple arguments\n        request = {\n            \"favorite_color\": args.color,\n            \"favorite_animal\": args.animal\n        }\n        \n        # Store the data\n        data_id = redis_store.store_user_data(request)\n        if data_id:\n            # Show what actually got stored in Redis\n            stored_data = redis_store.client.hgetall(f\"user_profile:{data_id}\")\n            print(json.dumps({\n                \"request_id\": data_id,\n                \"stored_data\": stored_data\n            }))\n            exit(0)\n        else:\n            print(json.dumps({\n                \"error\": \"Failed to store data in Redis\"\n            }))\n            exit(1)\n    \n    except RedisConnectionError as e:\n        print(json.dumps({\n            \"error\": str(e)\n        }))\n        exit(1)\n    finally:\n        try:\n            redis_store.client.close()\n            logger.debug(\"Redis connection closed\")\n        except:\n            pass\n"
        },
        {
          "source": null,
          "destination": "/tmp/requirements.txt",
          "content": "redis>=5.0.0\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"store_favorites\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"color (Required)<br/>User's favorite color\"):::paramClass\n        Param1(\"animal (Required)<br/>User's favorite animal\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install -r /tmp/requirements.txt > /dev/null ...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>REDIS_HOST<br/>REDIS_PORT<br/>KUBIYA_USER_EMAIL\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    },
    {
      "name": "retrieve_favorites",
      "source": null,
      "alias": null,
      "description": "Retrieves user's favorite color and animal from Redis using the request ID",
      "type": "docker",
      "content": "\npip install -r /tmp/requirements.txt > /dev/null 2>&1\n\npython /tmp/redis_retrieve_example.py \"{{ .request_id }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "request_id",
          "type": null,
          "description": "Request ID to retrieve the stored favorites",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "REDIS_HOST",
        "REDIS_PORT"
      ],
      "secrets": [],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/redis_retrieve_example.py",
          "content": "import redis\nimport json\nimport logging\nfrom typing import Dict, Optional\nimport argparse\nimport os\n\nclass RedisConnectionError(Exception):\n    \"\"\"Custom exception for Redis connection errors\"\"\"\n    pass\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass RedisRetriever:\n    def __init__(self):\n        host = os.getenv('REDIS_HOST')\n        port = int(os.getenv('REDIS_PORT', '6379'))\n        \n        if not host:\n            logger.error(\"REDIS_HOST environment variable is not set\")\n            raise RedisConnectionError(\"REDIS_HOST environment variable is not set\")\n            \n        self.client = redis.Redis(\n            host=host,\n            port=port,\n            decode_responses=True,\n            socket_timeout=5.0,\n            socket_connect_timeout=5.0\n        )\n    \n    def get_user_data(self, data_id: str) -> Optional[Dict]:\n        \"\"\"\n        Retrieve user data from Redis using the data ID\n        Returns the data if found, None if not found or error\n        \"\"\"\n        try:\n            # Get data from Redis\n            data = self.client.hgetall(f\"user_profile:{data_id}\")\n            \n            if not data:\n                logger.warning(f\"No data found for ID: {data_id}\")\n                return None\n            \n            logger.info(f\"Successfully retrieved data for ID: {data_id}\")\n            return data\n            \n        except redis.RedisError as e:\n            logger.error(f\"Failed to retrieve data from Redis: {str(e)}\")\n            return None\n    \n    def delete_user_data(self, data_id: str) -> bool:\n        \"\"\"\n        Delete user data from Redis using the data ID\n        Returns True if successful, False otherwise\n        \"\"\"\n        try:\n            # Delete data from Redis\n            result = self.client.delete(f\"user_profile:{data_id}\")\n            \n            if result:\n                logger.info(f\"Successfully deleted data for ID: {data_id}\")\n                return True\n            \n            logger.warning(f\"No data found to delete for ID: {data_id}\")\n            return False\n            \n        except redis.RedisError as e:\n            logger.error(f\"Failed to delete data from Redis: {str(e)}\")\n            return False\n    \n    def close(self):\n        \"\"\"Close the Redis connection\"\"\"\n        try:\n            self.client.close()\n            logger.debug(\"Redis connection closed\")\n        except:\n            pass\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Retrieve request data from Redis\")\n    parser.add_argument(\n        \"request_id\",\n        help=\"The request ID to retrieve data for\"\n    )\n\n    args = parser.parse_args()\n    \n    # Example usage\n    redis_retriever = RedisRetriever()\n    \n    try:\n        # Retrieve request data using the request ID\n        request_data = redis_retriever.get_user_data(args.request_id)\n        \n        if request_data:\n            print(\"\\nRetrieved data:\")\n            print(json.dumps({\n                \"request_id\": args.request_id,\n                \"data\": {\n                    \"favorite_color\": request_data.get(\"favorite_color\"),\n                    \"favorite_animal\": request_data.get(\"favorite_animal\"),\n                    \"timestamp\": request_data.get(\"timestamp\"),\n                    \"email\": request_data.get(\"email\")\n                }\n            }, indent=2))\n            \n            # Delete the data after successful retrieval\n            if redis_retriever.delete_user_data(args.request_id):\n                logger.info(f\"Data cleaned up for request ID: {args.request_id}\")\n            else:\n                logger.warning(f\"Failed to clean up data for request ID: {args.request_id}\")\n        else:\n            print(json.dumps({\n                \"error\": f\"No data found for request ID: {args.request_id}\"\n            }))\n            exit(1)\n            \n    except RedisConnectionError as e:\n        print(json.dumps({\n            \"error\": str(e)\n        }))\n        exit(1)\n    finally:\n        redis_retriever.close() \n"
        },
        {
          "source": null,
          "destination": "/tmp/requirements.txt",
          "content": "redis>=5.0.0\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"retrieve_favorites\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"request_id (Required)<br/>Request ID to retrieve the stored favorites\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install -r /tmp/requirements.txt > /dev/null ...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>REDIS_HOST<br/>REDIS_PORT\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    }
  ],
  "errors": [],
  "python_bundle_version": "3.11.9"
}